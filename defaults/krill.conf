# Specify how to set up the HTTPS certificate for Krill
#   existing: Expects an existing certificate and key in $data_dir/ssl
#   generate: Will generate a new key-pair and self-signed cert if
#             they cannot be found in $data_dir/ssl
#
# Note: we strongly recommend that you use a proxy like nginx, apache, or
# <your-choice-here> for HTTPS on a public network.
#
### https_mode = "generate"

# Specify the ip address and port number that the server will use.
#
# Note: we recommend that you use the defaults and use a proxy if you
# must make your Krill instance accessible remotely.
#
### ip             = "localhost"
### port           = 3000

# Specify the directory where the publication server will store its data.
# Note that clustering through a shared data directory is not supported.
# But, we plan to look into a proper clustering solution later.
#
### data_dir = "./data"

# Archive publication events after X days. If you do NOT set this
# value then Krill will not do any archiving.
#
# If enabled this option will make sure that the republish events,
# where your CA simply generates a new Manifest and CRL are archived
# after the given number of days.
#
# If you run Krill as a Publication Server then this option will
# enable the archiving of publication deltas received by your server
# from CAs.
#
# Archived commands (containing e.g. details of when the change happened),
# and following events will be moved to an "archived" subdirectory under
# your data directory as follows:
#   $data_dir/pubd/0/archived      <-- for Publication Server
#   $data_dir/cas/ca/archived      <-- for a CA named 'ca'
#
# If you want to save space you can delete the files from these archived
# directories, e.g. from cron. However, you could also archive them in
# a different way: e.g. compress and move to long term storage. Krill will
# no longer need this data, but if you ever wanted to see these details in
# history you would need to move them back into the parent directory of
# the 'archived' directory.
#
# To enable this set the following key value pair.
#
### archive_threshold_days = 7

# Specify the path to the PID file for Krill.
#
# Defaults to "krill.pid" under the 'data_dir' specified above.
#
### pid_file = "./data/krill.pid"

# Specify the base public service URI hostname and port.
#
# The default service URI is set to https://localhost:3000/ regardless of the
# IP and port configured above (but matching their default). This is fine for
# simple setups where you use Krill to run your own CA only and you use the
# CLI from localhost.
#
# However, if you need to access Krill remotely, or if you are serving as a
# parent CA, or Publication Server, to others, then make sure that you use a
# public URI here *and* make sure that you use a proxy server with a proper
# HTTPS certificate in front of Krill.
#
# At present this MUST be an https URI with a hostname and optional port number only.
# It is not allowed to use a Krill specific path prefix. If you have a strong
# motivation for this, then please commont on the following github issue:
# https://github.com/NLnetLabs/krill/issues/263
#
# Krill UI, API and service URIs will be derived as follows:
#  <service_uri>api/v1/...                (api)
#  <service_uri>rfc8181                   (for remote publishers)
#  <service_uri>rfc6492                   (for remote children)
#  <service_uri>rrdp/..                   (override with rddp_service_uri, see below)
#  <service_uri>...                       (various UI resources)
### service_uri = "https://localhost:3000/"

# Specify whether an embedded repository should be started. For many users
# it will be better to use a repository server provided by a third party, e.g.
# the RIR or NIR under which resources are received.
#
# Note that an existing embedded repository server will be removed if this
# setting is set to 'false' (default) AND there are no current publishers (i.e.
# all CAs use an external repository).
#
# For more information on running Krill as Publication Server see:
# https://rpki.readthedocs.io/en/latest/krill/publication-server.html
#
### repo_enabled = false

# Specify the base rsync repository for this server. Publishers will get
# a base URI that is based on the 'publisher_handle' in the XML file.
#
# Note, you need to set this parameter if (and only if) you chose to enable
# the repository function above (repo_enabled). If you did, you should set up
# an rsync daemon to expose $data_dir/rsync to serve this data. The uri defined
# here should match the module name in your rsync configuration.
#
# Furthermore.. note that the default 'localhost' is only allowed to be used
# when the KRILL_TEST ENV variable has been set.
#
### rsync_base = "rsync://localhost/repo/"

# Note, you may need to set this parameter if you chose to enable the repository
# function above (repo_enabled). By default Krill will use a public RRDP URI
# which is based on the service_uri. Use this directive use a different public
# URI to access the RRDP files.
#
### rrdp_service_uri = "$service_uri/rrdp/"

# Log level
#
# The maximum log level ("off", "error", "warn", "info", or "debug") for
# which to log messages.
#
# Defaults to "warn"
#
### log_level = "warn"

# Log type
#
# Where to log to. One of "stderr" for stderr, "syslog" for syslog, or "file"
# for a file. If "file" is given, the "log_file" field needs to be given, too.
#
### log_type = "file"

# Syslog facility
#
# The syslog facility to log to if syslog logging is used. Defaults to "daemon".
#
### syslog_facility = "daemon"

# Log file
#
# The path to the file to log to if file logging is used. If the path is
# relative, it is relative to the current working directory from which
# the binary is executed.
#
### log_file = "./krill.log"

# Master Authorization Bearer Token
#
# Define a master token that can be used to interact with the API. Token use
# is modelled after OAuth 2.0 Bearer Tokens (RFC 6750), which are expected be
# included as an HTTP header in requests by clients.
#
# If you do not specify a value here, the server will insist that you provide
# a token as an environment variable with the key "KRILL_AUTH_TOKEN".
#
# Note: see also the separate section below for configuring integration with an
# identity provider.
#
### auth_token =

# CA certificate refresh rate
#
# This defines the rate, in seconds, for Krill CAs to to contact their parent
# CA and query for updates in resource entitlements.
#
# Defaults to 10 minutes
#
### ca_refresh = 600

# Restrict size of messages sent to the API
#
# Default 256 kB
#
### post_limit_api = 262144

# Restrict size of messages sent to the RFC 8181 publication protocol
#
# Default 32MB (enough for a keyroll with about 8000 issued certificates)
#
### post_limit_rfc8181 = 33554432

# Specify a log directory for logging RFC 8181 (publication protocol)
# exchanges. If this directive is set Krill will log all meaningful
# RFC 8181 exchanges in this directory, meaning exchanges that resulted
# in a change or an error.
#
# If this directive is not specified, Krill will NOT log these exchanges.
# Do not set an empty value for the directive in this case, just leave
# it out.
#
# Defaults to NO logging!
#
### rfc8181_log_dir = </some/path>

# Restrict size of messages sent to the RFC 6492 up-down protocol
#
# Default 1MB (enough for a keyroll with certs of ~400kb, the biggest known cert is 220kB)
#
### post_limit_rfc6492 = 1048576

# Specify a log directory for logging RFC 6492 (up-down protocol)
# exchanges. If this directive is set Krill will log all meaningful
# RFC 6492 exchanges in this directory, meaning exchanges that resulted
# in a change or an error.
#
# If this directive is not specified, Krill will NOT log these exchanges.
# Do not set an empty value for the directive in this case, just leave
# it out.
#
# Defaults to NO logging!
#
### rfc6492_log_dir = </some/path>

# Enable loading BGP Dumps from RIS for ROA vs BGP analysis.
#
# bgp_risdump_enable = true
# bgp_risdump_v4_uri = http://www.ris.ripe.net/dumps/riswhoisdump.IPv4.gz
# bgp_risdump_v6_uri = http://www.ris.ripe.net/dumps/riswhoisdump.IPv6.gz


######################################################################################
#                                                                                    #
#                --------======== DANGER ZONE ========--------                       #
#                                                                                    #
#  Do not change the options below, unless you are really certain that you need to   #
#  override Krill's default behaviour.                                               #
#                                                                                    #
######################################################################################


# Set the following to true to force Krill to always perform full rechecks
# of its data directories at startup. This is disabled by default because
# if can slow down startup significantly.
#
# By default Krill will do some basic checks at startup already, and if any
# errors are encountered force a full recovery automatically: Krill will try
# to load all its state in its internal memory cache at startup. If there are
# no errors in reloading the latest 'info' about the state, any surplus data
# will be assumed to be the result from an incompletely finished transaction - or -
# a data directory backup which was taken during a transaction. In either case
# additional data is discarded and the last (committed) state is recreated.
#
# Note that this 'recovery' will make Krill fall back to the last possible
# consistent state that it can. But, there may be important changes missing.
# For example any changes in ROAs made after the last recoverable state will
# be missing. You will have to verify the state yourself.
#
# In short: use this option only if you suspect that there is an issue with
# your backed up data. And if you do, you may want to set the ENV variable
# "KRILL_UPGRADE_ONLY" as well, in order to force that Krill exits after doing
# all its data checks and clean ups, and you have a chance to check the logs
# before proceeding.
#
### always_recover_data = false


#
#                               ROA Aggregation
#
# It is recommended that separate ROAs are used for each authorized prefix, even
# though the RFC allows for multiple prefixes for the same ASN to be combined on
# a single ROA object. The reason for this is that the ROA will become invalid
# if any of the listed prefixes no longer appears on your CA's certificate. Note
# that Krill will automatically clean up over-claiming ROAs when it finds that its
# resources have been shrunk, but there is a possible time window where ROAs can
# be invalid before Krill discovers the shrinkage.
#
# That said, if there would be too many ROAs then this will impact all RPKI
# validators, therefore Krill will by default start aggregating ROAs per ASN
# when more than 100 ROAs would be issued. Conversely, Krill will start de-
# aggregating again when the number of authorizations drops below 90.
#
# This behaviour can be overridden with the following directives:
# roa_aggregate_threshold = 100
# roa_deaggregate_threshold = 90


#
#                               Republication Intervals
#
# The RPKI uses Manifests (RFC 6486) to communicate the list of current RPKI
# objects (such as ROAs) to RPKI Validators. Manifests are used to protect against
# attacks, or incidents, where Validators only see a partial view of the RPKI
# repository. For this to work properly Validators will need to know how 'fresh'
# the Manifests are - otherwise they would be vulnerable to replay attacks where
# they are presented old versions of Manifests thus withholding them from discovering
# new RPKI objects.
#
# Manifests have two important dates included in them:
# 1- the 'next update time'
# 2- an expiration time
#
# When the next update time is passed manifests will become 'stale'. This means
# the Validators may either warn about the objects listed in these manifests, or
# they may even reject these objects altogether. There is current discussion about
# aligning this behaviour in the IETF - but for the moment the outcome will vary
# between Validator implementations.
#
# When the expiration time (not after time on the embedded EE certificate of the
# Manifest) passes, then the Manifest will be considered invalid by all Validator
# implementations.
#
# So, if Validators are subject to replay attacks of Manifests they will be
# unaware until these times have passed. After these times the Manifest and all
# listed RPKI objects will become invalid. When ROA objects become invalid, this
# typically means that the Route Announcement will be considered "Not Found", rather
# than invalid. So, typically they would not be dropped, but they are no longer
# protected by RPKI.
#
# One could therefore argue that short times should be used. However, if the times
# chosen are too short, then this will leave your CA vulnerable to possible
# operational issues with its RPKI repository - or outages of your CA itself.
#
# So, in short, the chosen values are a balance between the wish to limit the
# vulnerability to replay attacks vs the time an operator has to solve operational
# issues.
#
# Krill uses the following defaults:
#
# The "next update" time is 24 hours:
# timing_publish_next_hours = 24
#
# The "not after time" on the EE certificate is 7 days from issuance:
# timing_publish_valid_days = 7
#
# Krill will automatically re-publish new Manifests if they would become stale
# in 8 hours. Because re-publication happens hourly, this leaves the operator
# with a minimum of 7 hours to fix issues if re-publication should fail.
# timing_publish_hours_before_next = 8


#
#                 ROA and Delegate Certificate Times
#
# Krill will issue ROAs, and child CA certificates if you have delegated resources
# to child CAs, with a "not after" time of 52 weeks from issuance, and it will
# re-issue those ROAs and certificates 4 weeks before they would expire.
#
# Because of the automatic renewal there should be no real need to use longer
# validity times. In fact using longer times could have a negative impact on
# Validator performance because the Certificate Revocation Lists would become
# bigger.
#
# So, we do NOT recommend overriding the following values, except perhaps for
# testing purposes:
# timing_child_certificate_valid_weeks = 52
# timing_child_certificate_reissue_weeks_before = 4
# timing_roa_valid_weeks = 52
# timing_roa_reissue_weeks_before = 4


################################################################################
#  E X P E R I M E N T A L - E X P E R I M E N T A L - E X P E R I M E N T A L #
#                                                                              #
#               Multi-User Authentication & Authorization (DRAFT!)             #
#                                                                              #
# NOTE: The settings in this section can be used to integrate the Krill web    #
# user interface (WEB UI) with an identity provider. This is an initial draft  #
# implementation and may change considerably and so no assumptions should be   #
# made based on the this implementation.                                       #
#                                                                              #
# When enabled these settings:                                                 #
#   - Will cause the WEB UI to direct users to login at the web portal of the  #
#     configured provider rather than be prompted in the WEB UI to enter the   #
#     Krill Master Authorization Bearer Token.                                 #
#                                                                              #
#   - Permit multiple distinct users to login to Krill without ever sharing    #
#     their login credentials with Krill, rather the user logs in with the     #
#     configured identity provider.                                            #
#                                                                              #
#   - Permit showing the identity of the logged in user in the WEB UI,         #
#     currently by the email attribute exposed by the identity provider to     #
#     Krill. While not yet implemented the intention is to also record this    #
#     identity in the Krill audit logs instead of attributing actions to Krill #
#     itself.                                                                  #
#                                                                              #
#   - Permit restricting the rights of the logged in user on a per user basis. #
#     Currently this is limited to assigning the user read-only or read-write  #
#     access but the implementation supports in principle extension to more    #
#     groups with fine grained rights, e.g. permit working with CAs but not    #
#     routes. It is also possible to restrict access to specific CAs.          #
#                                                                              #
#   - Do NOT influence the krillc command line tool. Krillc supports only      #
#     Master Authorization Bearer Token (see auth_token above) based           #
#     authentication and authorization with the krill server.                  #
#                                                                              #
# This implementation is intended to act as a basis for discussion and the     #
# exact set of capabilities and configuration mechanisms to support them is    #
# expected to evole or change completely as a result.                          #
#                                                                              #
#  E X P E R I M E N T A L - E X P E R I M E N T A L - E X P E R I M E N T A L #
################################################################################


# A note about providers:
#
# This implementation abstracts the existing Master Authorization Bearer Token
# based authentication into support for different providers, with initial
# support for three providers:
#
#   - Master Authorization Bearer Token for backward compatibility with
#     existing WEB UI users and to continue to support krillc and direct REST 
#     API access using the single configured token.
#
#   - OpenID Connect (tested with RedHat KeyCloak and Azure ActiveDirectory)
#
#   - Config File auth provider for defining Krill users in the Krill config
#     file.
#
# Support for additional providers could be added, e.g. support for XML SAML
# assertion based identity providers.


# A note about state and security:
#
# While Krill server does not yet support running as an active-active cluster,
# this implementation deliberately does not add any in-memory state or
# dependency on an external data store to manage login session state. This is in
# order to avoid making any assumptions about or placing any constraints on any
# future active-active clustering support that may be added to Krill.
#
# Krill respects the expiration time of the login session granted by the OpenID
# Connect provider. This requires that Krill keeps a copy of the granted Access
# and Refresh Tokens as both are needed to attempt to extend the login session
# at the provider. These tokens are sensitive and would usually be stored in
# some sort of persistent, perhaps cluster capable, storage backend. To avoid
# adding such state to Krill at this time these tokens are stored by the client
# browser, just as the Master Authorization Bearer Token is already stored at
# the browser.
#
# To avoid leaking these sensitive tokens to the browser and possibly beyond to
# a malicious actor, the state is encrypted by the Krill server and is opaque to
# the WEB UI (it doesn't need to know what is in it, only to store it). Only the
# Krill server is able to decrypt the state. The state is encoded as a bearer
# token and sent to Krill exactly the same way that the Master Authorization
# Bearer Token is sent to Krill today, but rather than being a string of
# characters with no inherent meaning they can now be decrypted to reveal the
# access and refresh tokens, and also the role and thus rights that the user has
# in Krill.
#
# The current implementation uses insecure key, nonce etc values for encryption
# and insecure state and nonce etc values with the OpenID Connect protocol. The
# various encryption, OAuth 2.0 and OpenID Connect Core 1.0 security best 
# practice guidelines need to be reviewed and the implementation modified to
# implement them. However, the current implementation is arguably not worse than
# and in fact slightly better than the current Krill Master Authorization Bearer
# Token based approach (as it uses temporary tokens with some encryption vs a
# fixed single token stored in the browser in plaintext and known to multiple
# parties.


# Auth type
#
# Which provider to use for authentication (AuthN), authorization (AuthZ) and
# identity (ID).
#
# Supported values: "master-token" (default), "openid-connect" or "config-file".
#
# At-a-glance comparison:
# =======================
#  Setting Value     AuthN       AuthZ           ID
#  -----------------------------------------------------------------------------
#  "master-token"    auth_token  role = "admin"  id = "master-token@krill.conf"
#  -----------------------------------------------------------------------------
#  "openid-connect"  provider    provider        provider
#                    checked     supplied        supplied
#  -----------------------------------------------------------------------------
#  "config-file"     values are taken from the [auth_users] section in this
#                    config file
#  -----------------------------------------------------------------------------
#
# Notes for "master-token":
# =========================
# auth_type = "master-token" is the default if this setting is omitted. This 
# mode is provided for backward compatibility with existing Krill deployments. 
# The Master Authorization Bearer Token will grant any client full access to 
# Krill, equivalent to the new "admin" role. The value of the Master 
# Authorization Bearer Token continues to be controlled by the auth_token
# setting above or by the KRILL_AUTH_TOKEN environment variable.
#
# BACKWARD INCOMPATIBILITY: Actions performed by a client supplying the Krill 
# Master Authorization Bearer Token will NO LONGER be attributed in the Krill
# audit log to actor "krill" but instead to "master-token@krill.conf". This is
# to separate them from internal background actions performed by Krill itself
# which will continue to be attributed to actor "krill".
#
# Notes for "openid-connect":
# ===========================
# When setting auth_type = "openid-connect" you MUST also then supply the
# "auth_openidconnect" settings documented below.
#
# BACKWARD COMPATIBILITY: Using this provider does NOT currently disable the
# "master-token" provider. Instead it is used as a fallback when verifying REST
# API Authorization HTTP header bearer token values. This is so that krillc and
# 3rd party custom REST API clients of Krill continue to work. It is NOT
# currently possible however when auth_type = "openid-connect" to use the 
# Master Authorization Bearer Token to login with the WEB UI.
#
# Notes for "config-file":
# ========================
# auth_type = "config-file" causes Krill to read user identity, authentication
# and authorization details from configuration values supplied by the operator
# in this config file.
#
# BACKWARD COMPATIBILITY: Using this provider does NOT currently disable the
# "master-token" provider. See the explanation given for "openid-connect" above.
#
### auth_type = "master-token"


# Config file auth provider details (mandatory when auth_type = "config-file")
#
# Support values:
#   auth_users = { "user_id" = { ... } [, "another_id" = { ... }, ...] }
#
# Alternative syntax:
#  [auth_users]
#  "user_id" = { ... }
#  "another_id" = { ... }
#
# The config file auth provider allows you to define one or more users which can
# then be used to login to the Krill WEB UI.
#
# Note about password hashes:
# ===========================
# Krill does not support specifying passwords for users, instead you must supply
# password hashes. Correct hash values (and in fact entire user configs) can be
# generated using the krillc command line tool, e.g.
#
#   $ krillc config user --id test2 --exccas ca2 --role gui_read_only
#   Enter the password to hash: some password
# 
#   [auth_users]
#   "test2" = { role="gui_read_only", cas=["!ca2"], password_hash="e62...7ea" }
#
# You can then copy-paste the generated config section, or just the line for the
# user, into this file.
#
# Per user syntax:
# ================
# For each user the following fields can be specified:
# 
#   id
#   role
#   cas
#   password_hash
#
# auth_users.id (mandatory)
# =============
# The name or email address or other identifier for the user. Will be used both
# as the username to login to the Krill WEB UI and will also be the value that
# is attributed in the Krill command history to actions performed by the user.
# May be optionally double-quoted which may be required when using particular
# characters in the id.
#
# auth_users.<some_id>.role (optional)
# =========================
# Supported values:
#   role = "admin", "gui_read_only" or "gui_read_write"
#
# The role the user will have when logged in to Krill. Defaults to admin.
#
# auth_users.<some_id>.cas (optional)
# ========================
# Supported values:
#   cas = ["...", "!..."]
#
# One or more Certificate Authority handles to which the user will either be
# limited to, or when the CA handle is prefixed by '!' (without the quotes)
# defines CAs that the user is unable to see or interact with.
#
# Note: CA handles are visible in the repository content and metrics output by
# Krill. This setting only restricts visibility of and interaction with
# specified CAs via the Krill WEB UI.
#
# auth_users.<some_id>.password_hash (mandatory)
# ==================================
# Supported values:
#   password_hash = "..."
#
# This config value is the hex representation of a SHA-256 hash computed of the
# users password.
#
# Example configuration:
# ======================
#   auth_type = "config-file"
#   
#   [auth_users]
#   "newconsent@user.com" = { role = "gui_read_write", password_hash="12..34" }
#   "blah@somewhere.com" = { role = "gui_read_only", password_hash="56..78", cas = ["ca2"] }
#   test = { cas=["!ca2"], password_hash="ba..ad" }
#   "test2" = { role="gui_read_only", cas=["!ca2"], password_hash="ba..ad" }
#
# In this configuration there is an administrator (user "test"), two read-only
# users and a user with read-write priviileges.
### auth_type = "config-file"
###
### [auth_users]
### ...


# OpenID Connect provider details (mandatory when auth_type = "openid-connect")
#
# Supported values:
#   auth_openidconnect = { issuer_url = "..", ... }
#
# Alternative syntax:
#   [auth_openidconnect]
#   issuer_url = ".."
#   ...
#
# In order to communicate with an OpenID Connect provider Krill must first be
# registered with that provider. As a result of registration you will be issued
# a client_id and a client_secret, and possibly also an issuer_url (or you may
# have to consult the provider documentation to determine the issuer_url).
#
# When auth_type = "openid-connect" these values MUST be provided to Krill via
# the following correspondingly named auth_openidconnect settings:
#
# The OpenID Connect provider must implement the following specifications:
#
#         https://openid.net/specs/openid-connect-core-1_0.html
#         https://openid.net/specs/openid-connect-discovery-1_0.html
#         https://openid.net/specs/openid-connect-rpinitiated-1_0.html
#
# At it's ${issuer_url}/.well-known/openid_configuration endpoint it MUST
# announce support for at least the following:
#
#   "issuer": ".."
#   "authorization_endpoint": "..",
#   "token_endpoint": "..",
#   "userinfo_endpoint": "..",
#   "jkws_uri": "..",
#   "scopes_supported": ["openid", "email"]
#   "response_types_supported": ["code"]
#   "response_modes_supported": ["query"]
#   "grant_types_supported": ["authorization_code"]
#   "id_token_signing_alg_values_supported": ["RS256"]
#   "end_session_endpoint": ".."
#
# ------------------------------------------------------------------------------
# A note about HTTPS certificates:
# ------------------------------------------------------------------------------
# If the provider URLS are HTTPS URLs (which they should be unless this
# deployment of Krill is only for testing) then the HTTPS certificate must have
# been issued by a CA in the O/S CA certificate store, i.e. either a well known
# authority that is included in the store by default, or a custom CA that you
# have added to the store yourself. Krill will fail to connect to a provider
# that uses a self-signed certificate or a certificate from an unknown root
# certificate authority. For more information see for example:
# http://manpages.ubuntu.com/manpages/xenial/man8/update-ca-certificates.8.html
# ------------------------------------------------------------------------------
#
# Note: "userinfo_endpoint" is currently required by this implementation but is
# only RECOMMENDED by the OpenID Core 1.0 specification, and if the desired ID
# metadata is available via the "token_endpoint" then it isn't needed. The
# implementation can be updated to make the userinfo_endpoint optional with
# additional configuration options to indicate what ID metadata to retrieve and
# from which endpoint.
#
# Note: "scopes_supported" value "email" is currently required by this
# implementation but per the OpenID Core 1.0 specification only the "openid"
# scope MUST be supported. Use of "email" should be made optional and in fact,
# related to the "userinfo_endpoint" note above, it should be configurable which
# claims to obtain from which endpoint. As a fallback we could use the ID token
# claim "sub" but it is intended to be unique and is likely not human readable,
# e.g. it has been seen in the form "cbf22f77-b85e-4dbe-a816-88cfc0b08f6d".
# Other strong candidates are "name" (or any of the various other name related
# "standard" claims) or a customer specific "additional" claim based on their
# own internal user ID system.
#
# Note: "end_session_endpoint" is defined by various OpenID Connect draft
# specifications relating to logout. In Krill it is used for the purpose defined
# in the OpenID Connect RP-Initiated Logout 1.0 spec, namely for Krill as the
# RP (OpenID Connect terms Krill a Relying Party in this context, which is
# particularly confusing given that the term Relying Party also has meaning in
# Krill's native RPKI domain) to be able to initiate logout of the user at the
# provider. Krill also requires that the endpoint either honours the
# "post_logout_redirect_uri" HTTP query parameter (defined as OPTIONAL in the
# spec) or that the provider can be configured with corresponding behaviour,
# i.e. to redirect the end-user user-agent (browser) back to Krill after logout
# is completed at the provider. If support for this is lacking it is undefined
# where the user will end up after logout, which is not an issue if the user
# was finished with Krill, but is annoying if the logout was done in order to
# re-login to Krill as a different user. At least one provider has been observed
# which does NOT support this endpoint.
#
# One possible alternative which this implementation does not yet support could
# be "revocation_endpoint" (https://tools.ietf.org/html/rfc7009 "OAuth 2.0 Token
# Revocation") which could be used to terminate the users login session at the
# provider without leaving the Krill WEB UI. At least one provider has been
# observed supporting this endpoint, which in that case would be useful because
# the same provider lacked the "end_session_endpoint".
#
#
# auth_openidconnect.issuer_url (mandatory when auth_type = "openid-connect")
# =============================
# Supported values:
#   issuer_url = "some URL"
#
# The URL of the OpenID Connect service such that appending
# /.well-known/openid_configuration to the URL enables Krill to download the
# https://openid.net/specs/openid-connect-discovery-1_0.html discovery metadata
# JSON document. This URL MUST match the "issuer" value in the discovery
# metadata document.
#
#
# auth_openidconnect.client_id (mandatory)
# ============================
# Supported values:
#   client_id = "some string"
#
# Issued to you by your OpenID Connect provider when you registered with them.
#
#
# auth_openidconnect.client_secret (mandatory)
# ================================
# Supported values:
#   client_secret = "some string"
#
# Issued to you by your OpenID Connect provider when you registered with them.
#
#
# auth_openidconnect.claims (optional)
# =========================
# Supported values:
#   claims = { role = { source = "..", jmespath = ".." }, cas { .. } }
#
# Alternative syntax:
#   [auth_openidconnect.claims]
#   role = { source = "..", jmespath = ".." }
#   cas = { source = "..", jmespath = ".." }
#   ...
#
# This subsection tells Krill where to find the users role, and optionally also
# the CAs they are permitted/denied access to, in the HTTP JSON responses
# received from the OpenID Connect provider when obtaining tokens or fetching
# additional user information from the provider.
#
# By default Krill extracts the value of a "role" claim in the OpenID Connect ID
# Token additional claims JSON response and performs no mapping of role values
# to the Krill internal role names. This is equivalent to this configuration:
#
#  [auth_openidconnect.claims]
#  role = { source = "id_token_additional_claim", jmespath = "role" }
#  
#  [auth_openidconnect.role_map]
#  admin = "admin"
#  gui_read_only = "gui_read_only"
#  gui_read_write = "gui_read_write"
#
# If present the optional "cas" field indicates where a CA access pattern for
# the user can be found. The syntax is similar to that of the "cas" field used
# with the "config-file" auth provider (see above) but instead of being an array
# of string values it is a string of comma-separated values. In both cases the
# format of the actual value is one of:
#
#   (actual values should not include the <angle> brackets)
#
#   <ca_handle>  - access to this CA is permitted (and by implication access to
#                  other CAs is denied unless they too are also explicitly
#                  permitteD
#
#   !<ca_handle> - access to this CA is denied
#
# E.g. if the ID token JSON response for a user contains a field called
# "ca_access" and for a given user the value of that field were "ca1,ca3" then
# that user would be permitted access to CAs "ca1" and "ca3" but not any other
# CA. Alternatively if the field value were "!ca1" then the user would be
# permitted access to any CA other than "ca1".
#
# By default Krill extracts the value of a "cas" claim in the OpenID Connect ID
# Token additional claims JSON response, if present.
#
# The JSON response to inspect for the "role" and "cas" claim fields and the
# exact field names to extract are determined by "source" and "jmespath"
# settings which are explained next.
#
#
# auth_openidconnect.claims.X.source (optional)
# ==================================
# Supported values:
#   source = "id_token_additional_claim" (default) or
#            "id_token_standard_claim" or
#            "user_info_additional_claim" or
#            "user_info_standard_claim"
#
# When source = "id_token_additional_claim" the claim value is taken from an
# additional claim [*1] field (by the name given in the "jmespath" setting) in
# the OpenID Connect Token Endpoint response.
#
# When source = "user_info_additional_claim" the claim value is taken from an
# additional claim [*1] field (by the name given in the "jmespath" setting) in
# the OpenID Connect UserInfo Endpoint response. NOTE: the UserInfo endpoint is
# OPTIONAL in the OpenID Connect Core 1.0 specification and thus may not be
# supported by your OpenID Connect provider.
#
# Similarly, "id_token_standard_claim" and "user_info_standard_claim" search
# within so-called "standard claims" [*2] as defined by the OpenID Connect Core
# 1.0 specification.
#
# [*1] https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims
# [*2] https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
# 
# Tip:
# If you are unsure which claim you need to extract from the response, inspect
# the debug level log output of Krill which will show what claim it tried to
# extract from where. At trace level you can insect the exact responses sent by
# the identity provider.
#
#
# auth_openidconnect.claims.X.jmespath (optional)
# ====================================
# Supported values:
#   jmespath = "any legal https://jmespath.org/ expression"
#
# For the "role" claim the default value is "role".
# For the "cas" claim the default value is "cas".
#
# This subsection tells Krill how to extract the Krill role name (that a logging
# in user should have) from the OpenID Connect provider response (guided by the
# source = ".." setting above).
#
# For example, given an ID Token additional claims response in JSON format that
# looks like this:
#   {
#       "nbf": 1603098980,
#       "rh": "0.AAAABRGBjvFPB0yDha9aua5Zt8OB8-qUrkBJigAdxo6_bEdzAPs.",
#       "groups": ["30045e33-1f96-4304-80a2-aab4974b4b86"],
#       "tid": "8e811105-4ff1-4c07-8385-af5ab9ae59b7",
#       "uti": "YYaTcowPT0OHF0Et5wzBAA",
#       "ver": "2.0"
#   }
#
# A jmespath = "groups[0]" expression tells Krill to use the 30045.. value as
# the claim value. If this were a role claim then in this case the role name is
# not a valid Krill role name and you would need to specify a mapping to valid
# role names. Role mapping is explained next.
#
#
# auth_openidconnect.role_map (optional)
# ===========================
# Supported values:
#  role_map = { gui_read_only = "..", gui_read_write = "..", admin = ".." }
#
# Alternative syntax:
#   [openidconnect.role_map]
#   admin = ".."
#   gui_read_only = ".."
#   gui_read_write = ".."
#
# This subsection tells Krill how to map unrecognised role names to internal
# Krill role names. This is needed for example if using Azure ActiveDirectory
# and you don't have AD Connect to do synchronization of proper group names or
# some other AD feature to serve group or role values (that you can control) in
# the OpenID Connect endpoint responses. By default Azure AD serves GUIDs for
# group object IDs instead of group names [*] as shown in the example above.
#
# [*] https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-fed-group-claims
#
# To work around this we can use a mapping like so, e.g.
#
#   [auth_openidconnect.role_map]
#   gui_read_only = "30045e33-1f96-4304-80a2-aab4974b4b86"
#   gui_read_write = "c5740b90-06fd-4ec2-b48c-c4a7019acf1d"
#
#
# auth_openidconnect.extra_login_scopes (optional)
# =====================================
# Supported values:
#   extra_login_scopes = [ "scope name", "scope name", .. ]
#
# Your OpenID Connect provider may require that Krill send additional scopes
# when directing users to login with the provider, and/or you may need to
# specify additional scopes in order for the provider to return the desired
# claims in ID Token or UserInfo JSON responses.
#
# Whether you need an extra login scopes and if so what their names are is
# determined by your OpenID Connect provider.
#
#
# auth_openidconnect.extra_login_params (optional)
# =====================================
# Supported values:
#   extra_login_params = { key = "value", "key" = "value" }
#
# Alternative syntax:
#   [openid_connect.extra_login_params]
#   key = "value"
#   key = "value"
#
# Your OpenID Connect provider may support additional login parameters, either
# from the OpenID Connect Core 1.0 specification [*1] or custom values specific
# to your provider.
#
# For example, with Azure ActiveDirectory you can specify "domain_hint" when
# your domain is federated with Azure AD so that the login form displayed is the
# one specific to your organization. Or for example you can specify "login_hint"
# to pre-fill the username field on the login form with a specified value which 
# can be handy when you don't have federation but you don't want to type the
# @suffix part of the sign-in email address on every login.
#
#
# Example RedHat KeyCloak configuration:
# ======================================
# This example is for a local test deployment of RedHat KeyCloak:
#
#   [auth_openidconnect]
#   issuer_url = "http://localhost:8082/auth/realms/myrealm"
#   client_id = "krill"
#   client_secret = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
#
# That's it! For this to work you must already have configured your KeyCloak
# instance e.g. with a realm, client (with redirect URI set), users and an
# attribute mapper (to expose a custom user attribute as a "role" claim).
#
#
# Example Azure ActiveDirectory configuration:
# ============================================
# This example is for a Microsoft Azure cloud ActiveDirectory instance.
#
#   [auth_openidconnect]
#   issuer_url = "https://login.microsoftonline.com/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/v2.0"
#   client_id = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
#   client_secret = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
#   
#   [auth_openidconnect.claims]
#   role = { source = "id_token_additional_claim", jmespath = "roles[0]" }
#   
#   [auth_openidconnect.role_map]
#   # role_mapping is optional, if the group/role names match those expected by
#   # Krill then mapping is not necessary.
#   gui_read_only = "30045e33-1f96-4304-80a2-aab4974b4b86"
#   gui_read_write = "c5740b90-06fd-4ec2-b48c-c4a7019acf1d"
#
# That's it! For this to work you must already have configured in the Azure
# portal your AD tenant, app registration and enterprise application settings
# (with redirect URI), users, group assignments and optional claim configuration
# (in the above example AD was configured to expose groups as roles).
#
# Note: This particular example doesn't define a mapping for the "admin" role or
# a "source" and/or "jmespath" for the "cas" claim and so would use the default
# values for these settings.
#
#
### auth_type = "openid-connect"
###
### [auth_openidconnect]
### issuer_url = ".."
### client_id = ".."
### client_secret = ".."
### extra_login_params = { .. = "", .. = "" }
### extra_login_scopes = [ "..", ".." ]
###
### [auth_openidconnect.claims]
### role = { .. }
### cas = { .. }
###
### [auth_openidconnect.role_map]
### <role_name> = ".."
### <role_name> = ".."