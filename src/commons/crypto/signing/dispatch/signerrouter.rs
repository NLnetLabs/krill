use std::{path::Path, sync::Arc};

use rpki::repository::crypto::{KeyIdentifier, PublicKey, PublicKeyFormat, Signature, SignatureAlgorithm, Signer, SigningError, signer::{KeyError, Sign, SignWithKey}};

use crate::commons::{
    crypto::{
        dispatch::signerprovider::SignerProvider,
        signers::{error::SignerError, softsigner::OpenSslSigner},
    },
    KrillResult,
};

#[cfg(feature = "hsm")]
use std::{collections::HashMap, str::FromStr, sync::RwLock};

#[cfg(feature = "hsm")]
use crate::commons::{
    api::Handle,
    crypto::{
        dispatch::{error::ErrorString, signerinfo::SignerMapper},
        signers::kmip::KmipSigner,
    },
};

#[cfg(feature = "hsm")]
const ENCODED_SIGNER_HANDLE_SEPARATOR: char = '-';

/// Manages multiple Signers and routes requests to the appropriate Signer.
///
/// SignerRouter:
///   - Creates the appropriate [Signer] implementations according to configuration.
///   - Handles registration of [Signer] instances with the [SignerMapper].
///   - Dispatches requests to the correct [Signer] instance, either because the request specified a [KeyIdentifier]
///     which is owned by a particular [Signer] instance, or because the kind of request dictates the kind of [Signer]
///     that should handle it (e.g. one-off signing or random number generation may be handled by a different [Signer]
///     than handles new key creation).
///
/// Note: If the `hsm` feature is not enabled all requests are routed to an instance of the [OpenSslSigner] for
/// backward compatibility with the behaviour of Krill before the introduction of the feature and the [SignerMapper] is
/// not created.
///
/// To avoid the complexities of dynamic dispatch in Rust we use enum based dispatch instead, as we know at compile time
/// which implementations of the [Signer] trait exist. The code noise caused by doing enum based dispatch is wrapped up
/// in the [SignerProvider] struct so we can focus on the business logic here instead.
///
/// [SignerProvider] instances are wrapped in [Arc] so that we can "assign" the same signer to multiple different
/// "roles", e.g. one-off signer, rand signer, keyroll signer, etc.
///
/// Additional complexity is introduced by the need to wrap the [Signer]s in a lock due to the use of `&mut` by the
/// [Signer] trait on the `create_key()` and `destroy_key()` functions. The latest, not yet released, version of the
/// `rpki-rs` crate which defines the [Signer] trait removes the `&mut` from the trait and so we will be able to remove
/// these locks and instead use interior mutability inside the [Signer] implementations as appropriate/necessary rather
/// than lock the entire [Signer]. Even if that is released we will not make those changes in the current code however
/// as that will introduce too many changes in one PR. See https://github.com/NLnetLabs/rpki-rs/issues/161 and
/// https://github.com/NLnetLabs/rpki-rs/pull/162 for more information.
///
/// Further, a signer may not be available at the time we wish to use it, perhaps it is down or being slow or a network
/// or configuration issue prevents us connecting to it at that time. Signers are therefore maintained in two distinct
/// sets: pending and active. Signers start in the pending set and are promoted to the active set once we are able to
/// verify that we can connect to and use them and determine which [SignerMapper] [Handle] they should be assigned.
#[derive(Debug)]
pub struct SignerRouter {
    /// The signer to use for creating new keys and generating random numbers.
    ///
    /// Exceptions:
    ///   - One-off signing keys are NOT created by the default signer. See `one_off_signer` below.
    ///   - Random numbers can only be generated by the default signer if it supports it. See `rand_fallback_signer`
    ///     below.
    default_signer: Arc<SignerProvider>,

    /// The signer to create, sign with and destroy a one-off key.
    ///
    /// As the security of a HSM isn't needed for one-off keys, and HSMs are slow, by default this should be an instance
    /// of [OpenSslSigner]. However, if users think the perceived extra security is warranted let them use a different
    /// signer for one-off keys if that's what they want.
    one_off_signer: Arc<SignerProvider>,

    /// The signer to use when a configured signer doesn't support generation of random numbers.
    rand_fallback_signer: Arc<SignerProvider>,

    /// A mechanism for identifying the signer [Handle] that owns the key with a particular [KeyIdentifier].
    ///
    /// Used to route requests to the signer that possesses the key. If a key was created using a signer that is no
    /// longer present in the config file then the [SignerMapper] may return a [Handle] which is not present in the
    /// `active_signers` set (see below) and thus for which we thus have no way of using the key.
    ///
    /// Conversely, if a key was deleted from the signer/HSM by an external entity without our knowledge then the
    /// [SignerMapper] may return a [Handle] for a signer which no longer possesses the key.
    ///
    /// A reference to the [SignerMapper] is also given to each [Signer] so that it can register the mapping of newly
    /// created keys by their [KeyIdentifier] to their [Signer] implementation specific internal key identifier, and
    /// in reverse to lookup the internal key identifier from A given [KeyIdentifier].
    #[cfg(feature = "hsm")]
    signer_mapper: Arc<SignerMapper>,

    /// A lookup table for resolving a signer [Handle] to its associated [SignerProvider] instance.
    ///
    /// Used for any operation which must be routed to the signer that owns the key, e.g. key deletion and signing
    /// (except one-off signing). First the []
    ///
    /// If a signer was used in the past to create a key but that signer is no longer present in the Krill config file
    /// it will not be present in this map and will thus not be usable. While we could keep a record of connection
    /// details for used signers even once they are removed from the config file we don't do that, the operator must
    /// ensure correct connection details are present in the config file. There are multiple reasons for this:
    /// connection details likely include secrets such as client certificates, keys, usernames and passwords; an
    /// operator may no longer wish to or have the right to use a particular signer/HSM; once we support multi-node
    /// deployment connection details to the signer/HSM may vary from one node to another so there is no single correct
    /// set of connection details to store in the history, e.g. if the HSM is clustered and each Krill node uses its
    /// nearest/same subnet HSM instance which has a different IP address from the HSM instance used by another Krill
    /// node in another subnet).
    ///
    /// This lookup table includes at least the default, one off and rand fallback signers and may also include other
    /// signers defined in the config file which were used to create keys in the past which are still in use. Note: a
    /// signer can be "defined" by the configuration without being explicitly present in the config file, e.g. if it is
    /// the default for a setting which was not set in the config file (i.e. if the [OpenSslSigner] is used as a
    /// fallback for a signer that doesn't support generating random numbers).
    ///
    /// NOTE: Currently we're still using hard-coded signers, we don't yet have support for being configured from the
    /// config file.
    ///
    /// [SignerProvider] instances are moved to this set from the `pending_signers` set once we are able to confirm that
    /// we can connect to them and can identify the correct signer [Handle] used by the [SignerMapper] to associate with
    /// keys created by that signer.
    #[cfg(feature = "hsm")]
    active_signers: RwLock<HashMap<Handle, Arc<SignerProvider>>>,

    /// The set of [SignerProvider] instances that are configured but not yet confirmed to be usable. All signers start
    /// off in this set and are moved to the `active_signers` set as soon as we are able to confirm them. See
    /// `active_signers` above.
    #[cfg(feature = "hsm")]
    pending_signers: RwLock<Vec<Arc<SignerProvider>>>,
}

#[cfg(feature = "hsm")]
struct SignerRoleAssignments {
    default_signer: Arc<SignerProvider>,
    one_off_signer: Arc<SignerProvider>,
    rand_fallback_signer: Arc<SignerProvider>,
}

/// Before HSM support was added we used a single OpenSSL based "soft" signer for all key management and signing
/// operations.
#[cfg(not(feature = "hsm"))]
impl SignerRouter {
    pub fn build(work_dir: &Path) -> KrillResult<Self> {
        let openssl_signer = Arc::new(SignerProvider::OpenSsl(OpenSslSigner::build(work_dir)?));

        Ok(SignerRouter {
            default_signer: openssl_signer.clone(),
            one_off_signer: openssl_signer.clone(),
            rand_fallback_signer: openssl_signer,
        })
    }

    fn get_signer_for_key(&self, _key_id: &KeyIdentifier) -> Result<Arc<SignerProvider>, SignerError> {
        Ok(self.default_signer.clone())
    }
}

/// With HSM support we are able to use different and even multiple signer implementations at once in Krill.
#[cfg(feature = "hsm")]
impl SignerRouter {
    pub fn build(work_dir: &Path) -> KrillResult<Self> {
        // The types of signer to initialize, the details needed to initialize them and the intended purpose for each
        // signer (e.g. signer for past keys, currently used signer, signer to use for a key roll, etc.) should come
        // from the configuration file. SignerRouter combines that input with its own rules, e.g. to route a signing
        // request to the correct signer we will need to determine which signer possesses the signing key, and the
        // signer to use to create a new key depends on whether the key is one-off or not and whether or not it is
        // being created for a key roll.

        // TODO: Once it becomes possible to configure how an HSM is used by Krill we need to decide what the
        // defaults should be and what should be configurable or not concerning HSM usage, and to document why, if
        // permitted, it is acceptable to use local keys, signing & random number genration instead of the more
        // secure HSM based alternatives (if available).
        let signer_mapper = Arc::new(SignerMapper::build(work_dir)?);

        // We don't know the signer handles yet. The signer implementations have to work out their own signer handle
        // when they are ready. Signers are moved from the signer collection to the map once while running when asked
        // they by that point have determined their own handle.
        let signers_by_handle = RwLock::new(HashMap::new());

        let roles = Self::build_signers(work_dir, signer_mapper.clone())?;

        // Having the same signer multiple times in this vector is less efficient but the impact is negligible and it
        // doesn't break anything if there are duplicates.
        let mut unique_signers = vec![
            roles.default_signer.clone(),
            roles.one_off_signer.clone(),
            roles.rand_fallback_signer.clone(),
        ];

        unique_signers.sort_by_key(|k| k.get_name().to_string());
        unique_signers.dedup_by_key(|k| k.get_name().to_string());

        let unique_signers = RwLock::new(unique_signers);

        // TODO: Once we can configure ourselves from the configuration file, we also need to create any signers that
        // are defined in the config but which don't have an active role, i.e. only exist to work with keys created by
        // a still active signer but not one that we create new keys with.

        Ok(SignerRouter {
            default_signer: roles.default_signer,
            one_off_signer: roles.one_off_signer,
            rand_fallback_signer: roles.rand_fallback_signer,
            active_signers: signers_by_handle,
            pending_signers: unique_signers,
            signer_mapper,
        })
    }

    #[cfg(not(feature = "hsm-tests"))]
    fn build_signers(work_dir: &Path, signer_mapper: Arc<SignerMapper>) -> KrillResult<SignerRoleAssignments> {
        // When the HSM feature is activated and we are not in test mode:
        //   - Use the HSM for key creation, signing, deletion, except for one-off keys.
        //   - Use the HSM for random number generation, if supported, else use the OpenSSL signer.
        //   - Use the OpenSSL signer for one-off keys.
        let openssl_signer = Arc::new(SignerProvider::OpenSsl(OpenSslSigner::build(
            work_dir,
            "OpenSslSigner - No config file name available yet",
            Some(signer_mapper.clone()),
        )?));

        let kmip_signer = Arc::new(SignerProvider::Kmip(KmipSigner::build(
            "KmipSigner - No config file name available yet",
            signer_mapper,
        )?));

        Ok(SignerRoleAssignments {
            default_signer: kmip_signer.clone(),
            one_off_signer: openssl_signer.clone(),
            rand_fallback_signer: openssl_signer,
        })
    }

    // TODO: Delete me once setup from Krill configuration is supported.
    #[cfg(feature = "hsm-tests")]
    fn build_signers(work_dir: &Path, signer_mapper: Arc<SignerMapper>) -> KrillResult<SignerRoleAssignments> {
        // When the HSM feature is activated AND test mode is activated:
        //   - Use the HSM for as much as possible to depend on it as broadly as possible in the Krill test suite..
        //   - Fallback to OpenSSL for random number generation if the HSM doesn't support it.
        let openssl_signer = Arc::new(SignerProvider::OpenSsl(OpenSslSigner::build(
            work_dir,
            "OpenSslSigner - No config file name available yet",
            Some(signer_mapper.clone()),
        )?));

        let kmip_signer = Arc::new(SignerProvider::Kmip(KmipSigner::build(
            "KmipSigner - No config file name available yet",
            signer_mapper,
        )?));

        Ok(SignerRoleAssignments {
            default_signer: kmip_signer.clone(),
            one_off_signer: kmip_signer.clone(),
            rand_fallback_signer: openssl_signer,
        })
    }

    /// Locate the [SignerProvider] that owns a given [KeyIdentifier], if the signer is active.
    ///
    /// If the signer that owns the key has not yet been promoted from the pending set to the active set or if no
    /// the key was not created by us or was not registered with the [SignerMapper] then this lookup will fail with
    /// [SignerError::KeyNotFound].
    fn get_signer_for_key(&self, key_id: &KeyIdentifier) -> Result<Arc<SignerProvider>, SignerError> {
        // Get the signer handle for the key
        let signer_handle = self
            .signer_mapper
            .get_signer_for_key(key_id)
            .map_err(|_| SignerError::KeyNotFound)?;

        // Get the SignerProvider for the handle, if the signer is active
        let signer = self.active_signers.read().unwrap().get(&signer_handle).cloned();

        signer.ok_or(SignerError::KeyNotFound)
    }
}

/// When the "hsm" feature is enabled we can no longer assume that signers are immediately and always available as was
/// the case without the "hsm" feature when only the OpenSslSigner was supported. We therefore keep created signers on
/// standby in a "pending" set until we can verify that they are reachable and usable and can determine which
/// [SignerMapper] [Handle] to assign to them.
///
/// The Krill configuration file (TODO) defines named signers with a type (openssl, kmip or pkcs#11) and type specific
/// settings (key dir path, hostname, port number, TLS certificate paths, username, password, slot id, etc) and assigns
/// signers a role (default signer, one-off signer, rand signer, keyroll signer, etc) either explicitly or by default.
///
/// Keys created using signers in a previous Krill process MUST have been registered by the signer with the
/// [SignerMapper] to indicate that the signer owns/possesses the key, and how to map from the [KeyIdentifier] to any
/// internal signer specific key id. When a new Krill process starts it will need to know for any given [KeyIdentifier]
/// which signer that was created should be used to work with the key. Rather than rely on operator supplied signer
/// names being stable or requiring operators to also maintain a stable signer id in the config, we instead "bind" the
/// signer backend to the signer handle that owns the set of keys stored in the [SignerMapper].
///
/// Binding is done by asking the signer on first use to create a new key pair for which we save the public key and the
/// signer specific internal private key identifier and combine them into a unique [Handle] for use by the signer with
/// the [SignerMapper]. We also store some metadata about the signer backend with the [Handle] in the [SignerMapper]
/// which allows us to see if the configuration and/or backend properties change over time.
///
/// On subsequent bindings we determine which signer maps to which [SignerMapper] [Handle] by extracting the private key
/// signer specific internal id from the [Handle] and asking each signer to sign a challenge using that key. We then
/// verify the signature using the saved public key. If the signer doesn't know the internal private key id or produces
/// an incorrect signature we know that the signer doesn't possess the binding key and thus likely isn't the signer we
/// should go to for the keys mapped to the [SignerMapper] [Handle] corresponding to the binding key.
///
/// By binding this way we both verify that the signer is usable (at least for key pair creation and signing) and that
/// we are using a signer that should have the keys we expect it to possess.
///
#[cfg(feature = "hsm")]
enum IdentifyResult {
    Unavailable,
    Corrupt,
    Identified(Handle),
    Unusable,
    Unidentified,
}

#[cfg(feature = "hsm")]
enum RegisterResult {
    NotReady,
    ReadyVerified(Handle),
    ReadyUnusable,
}

#[cfg(not(feature = "hsm"))]
impl SignerRouter {
    fn bind_ready_signers(&self) {}
}

#[cfg(feature = "hsm")]
impl SignerRouter {
    fn bind_ready_signers(&self) {
        if let Err(err) = self.do_ready_signer_binding() {
            error!("Internal error: Unable to bind ready signers: {}", err);
        }
    }

    fn do_ready_signer_binding(&self) -> Result<(), String> {
        if self.has_pending_signers() {
            // Fetch the handle of every signer previously created in the [SignerMapper] to see if any of the pending
            // signers is actually one of these or is a new signer that we haven't seen before.
            let candidate_handles = self.get_candidate_signer_handles()?;

            // Block until we can get a write lock on the set of pending_signers as we will hopefully remove one or
            // more items from the set. Standard practice in Krill is to panic if a lock cannot be obtained.
            let mut pending_signers = self.pending_signers.write().unwrap();

            let mut abort_flag = false;

            // For each pending signer see if we can verify it and if so move it from the pending set to the active set.
            pending_signers.retain(|signer_provider| -> bool {
                if abort_flag {
                    return true;
                }

                let signer_name = signer_provider.get_name().to_string();

                // See if this is a known signer that whose signature matches the public key stored in the
                // [SignerMapper] for the signer.
                self.identify_signer(signer_provider, &candidate_handles)
                    .and_then(|verify_result| match verify_result {
                        IdentifyResult::Unavailable => {
                            // Signer isn't ready yet, leave it in the pending set and try again next time.
                            Ok(true)
                        }
                        IdentifyResult::Identified(signer_handle) => {
                            // Signer is ready and verified, add it to the active set.
                            self.active_signers
                                .write()
                                .unwrap()
                                .insert(signer_handle, signer_provider.clone());
                            info!("Signer '{}' is ready for use", signer_name);
                            // And remove it from the pending set
                            Ok(false)
                        }
                        IdentifyResult::Unidentified => {
                            // Signer is ready and new, register it and move it to the active set
                            self.register_new_signer(signer_provider).and_then(
                                |register_result| match register_result {
                                    RegisterResult::NotReady => {
                                        // Strange, it was ready just now when we verified it ... leave it in the
                                        // pending set and try again next time.
                                        Ok(true)
                                    }
                                    RegisterResult::ReadyVerified(signer_handle) => {
                                        // Signer is ready and verified, add it to the active set.
                                        self.active_signers
                                            .write()
                                            .unwrap()
                                            .insert(signer_handle, signer_provider.clone());
                                        info!("Signer '{}' is ready for use", signer_name);
                                        // And remove it from the pending set
                                        Ok(false)
                                    }
                                    RegisterResult::ReadyUnusable => {
                                        // Signer registration failed, remove it from the pending set
                                        warn!("Signer '{}' is not usable", signer_name);
                                        Ok(false)
                                    }
                                },
                            )
                        }
                        IdentifyResult::Unusable => {
                            // Signer is ready and unusable, remove it from the pending set
                            warn!("Signer '{}' is not usable", signer_name);
                            Ok(false)
                        }
                        IdentifyResult::Corrupt => {
                            // This case should never happen as this variant is handled in the called code
                            Err(ErrorString::new("Internal error: invalid handle"))
                        }
                    })
                    .unwrap_or_else(|err| {
                        error!("Signer '{}' could not be bound: {}. Aborting.", signer_name, *err);
                        abort_flag = true;
                        true
                    })
            });
        }

        Ok(())
    }

    fn has_pending_signers(&self) -> bool {
        !self.pending_signers.read().unwrap().is_empty()
    }

    fn get_candidate_signer_handles(&self) -> Result<Vec<Handle>, String> {
        Ok(self
            .signer_mapper
            .get_signer_handles()
            .map_err(|err| format!("Failed to get signer handles: {}", err))?)
    }

    fn identify_signer(
        &self,
        signer_provider: &Arc<SignerProvider>,
        candidate_handles: &[Handle],
    ) -> Result<IdentifyResult, ErrorString> {
        let config_signer_name = signer_provider.get_name().to_string();

        // First try any candidate handle whose signer name matches the name of the signer provider then fall back to
        // trying other candidate handles, as perhaps the signer was renamed in the config file and no longer matches by
        // name but can still be matched by verifying a new signing signature with the stored public key of the other
        // candidate handles.
        let mut ordered_candidate_handles = Vec::new();
        for candidate_handle in candidate_handles {
            let stored_signer_name = self.signer_mapper.get_signer_name(candidate_handle)?;
            if stored_signer_name == config_signer_name {
                ordered_candidate_handles.insert(0, candidate_handle);
            } else {
                ordered_candidate_handles.push(candidate_handle);
            }
        }

        for candidate_handle in ordered_candidate_handles {
            let res = self.is_signer_identified_by_handle(signer_provider, candidate_handle)?;
            match res {
                IdentifyResult::Unidentified => {
                    // Signer was contacted and no errors were encountered but it doesn't know the key encoded in the
                    // given handle. Try again with the next handle.
                    continue;
                }
                IdentifyResult::Corrupt => {
                    // The candidate handle or signer public key is invalid so no key could be extracted to present to
                    // the signer. Try again with the next handle.
                    continue;
                }
                IdentifyResult::Unavailable | IdentifyResult::Unusable | IdentifyResult::Identified(_) => {
                    // No need to try the next candidate key, let the caller process the result.
                    return Ok(res);
                }
            }
        }

        // No errors occurred while contacting the signer but it doesn't know any of our candidate keys so this must be
        // a new signer that should be registered.
        Ok(IdentifyResult::Unidentified)
    }

    fn is_signer_identified_by_handle(
        &self,
        signer_provider: &Arc<SignerProvider>,
        candidate_handle: &Handle,
    ) -> Result<IdentifyResult, ErrorString> {
        let (key_identifier, signer_private_key_id) = match Self::decode_signer_handle(candidate_handle) {
            Err(err) => {
                error!(
                    "Internal error: Signer handle '{}' is invalid: {}",
                    candidate_handle, *err
                );
                return Ok(IdentifyResult::Corrupt);
            }
            Ok(res) => res,
        };

        let handle_name = self.signer_mapper.get_signer_name(candidate_handle)?;
        let signer_name = signer_provider.get_name().to_string();
        trace!(
            "Attempting to identify signer '{}' using identity key stored for signer '{}'",
            signer_name,
            handle_name
        );

        let public_key = match self.signer_mapper.get_signer_public_key(candidate_handle) {
            Ok(res) => res,
            Err(err) => {
                error!(
                    "Internal error: Identity public key for signer '{}' is invalid: {}",
                    handle_name, err
                );
                return Ok(IdentifyResult::Corrupt);
            }
        };

        if public_key.key_identifier() != key_identifier {
            error!(
                "Internal error: signer handle '{}' is invalid: key identifier mismatch",
                candidate_handle
            );
            return Ok(IdentifyResult::Corrupt);
        }

        let challenge = "Krill signer verification challenge".as_bytes();
        let signature = match signer_provider.sign_registration_challenge(&signer_private_key_id, challenge) {
            Err(SignerError::SignerUnavailable) => {
                debug!("Signer '{}' could not be contacted", signer_name);
                return Ok(IdentifyResult::Unavailable);
            }
            Err(SignerError::KeyNotFound) => {
                debug!(
                    "Signer '{}' not matched: private key id '{}' not found",
                    signer_name, signer_private_key_id
                );
                return Ok(IdentifyResult::Unidentified);
            }
            Err(err) => {
                error!("Signer '{}' is unusable: {}", signer_name, err);
                return Ok(IdentifyResult::Unusable);
            }
            Ok(res) => res,
        };

        if public_key.verify(challenge, &signature).is_ok() {
            debug!("Signer '{}' is ready and known, binding", signer_name);
            let signer_info = signer_provider.get_info().unwrap_or("No signer info".to_string());

            // Drop the read lock so that we can acquire a write lock
            std::mem::drop(signer_provider);

            signer_provider.set_handle(candidate_handle.clone());

            if let Err(err) = self.signer_mapper.change_signer_name(candidate_handle, &signer_name) {
                // This is unexpected and perhaps indicative of a deeper problem but log and keep going.
                error!(
                    "Internal error: Failed to change name of signer to '{}': {}",
                    signer_name, err
                );
            }
            if let Err(err) = self.signer_mapper.change_signer_info(candidate_handle, &signer_info) {
                // This is unexpected and perhaps indicative of a deeper problem but log and keep going.
                error!(
                    "Internal error: Failed to change info for signer '{}' to '{}': {}",
                    signer_name, signer_info, err
                );
            }

            debug!("Signer '{}' binding complete", signer_name);
        } else {
            debug!(
                "Signer '{}' not matched: incorrect signature created with private key '{}'",
                signer_name, signer_private_key_id
            );
        }

        Ok(IdentifyResult::Identified(candidate_handle.clone()))
    }

    fn register_new_signer(&self, signer_provider: &Arc<SignerProvider>) -> Result<RegisterResult, ErrorString> {
        let signer_name = signer_provider.get_name().to_string();

        let (public_key, signer_private_key_id) = match signer_provider.create_registration_key() {
            Err(SignerError::SignerUnavailable) => return Ok(RegisterResult::NotReady),
            Err(_) => return Ok(RegisterResult::ReadyUnusable),
            Ok(res) => res,
        };

        let challenge = "Krill signer verification challenge".as_bytes();
        let signature = match signer_provider.sign_registration_challenge(&signer_private_key_id, challenge) {
            Err(SignerError::SignerUnavailable) => return Ok(RegisterResult::NotReady),
            Err(_) => return Ok(RegisterResult::ReadyUnusable),
            Ok(res) => res,
        };

        if !public_key.verify(challenge, &signature).is_ok() {
            error!("Signer '{}' challenge signature is invalid", signer_name);
            return Ok(RegisterResult::ReadyUnusable);
        }

        debug!("Signer '{}' is ready and new, binding", signer_name);

        let new_signer_handle = Self::encode_signer_handle(public_key.key_identifier(), &signer_private_key_id)?;
        let signer_info = signer_provider.get_info().unwrap_or("No signer info".to_string());

        signer_provider.set_handle(new_signer_handle.clone());
        self.signer_mapper
            .add_signer(&new_signer_handle, &signer_name, &signer_info, &public_key)
            .unwrap(); // TODO: handle me

        debug!("Signer '{}' binding complete", signer_name);
        Ok(RegisterResult::ReadyVerified(new_signer_handle))
    }

    fn encode_signer_handle(key_id: KeyIdentifier, signer_private_key_id: &str) -> Result<Handle, ErrorString> {
        Ok(Handle::from_str(&hex::encode(format!(
            "{}{}{}",
            key_id, ENCODED_SIGNER_HANDLE_SEPARATOR, signer_private_key_id
        )))?)
    }

    fn decode_signer_handle(handle: &Handle) -> Result<(KeyIdentifier, String), ErrorString> {
        String::from_utf8(hex::decode(handle)?)?
            .split_once(ENCODED_SIGNER_HANDLE_SEPARATOR)
            .ok_or(ErrorString::new("Invalid handle: missing separator"))
            .and_then(|(kid_str, pkey_id)| Ok((KeyIdentifier::from_str(kid_str)?, pkey_id.to_string())))
    }
}

impl Signer for SignerRouter {
    type KeyId = KeyIdentifier;
    type Error = SignerError;

    fn create_key(&self, algorithm: PublicKeyFormat) -> Result<Self::KeyId, Self::Error> {
        self.bind_ready_signers();
        self.default_signer.create_key(algorithm)
    }

    fn get_key_info(&self, key_id: &KeyIdentifier) -> Result<PublicKey, KeyError<Self::Error>> {
        self.bind_ready_signers();
        self.get_signer_for_key(key_id)?.get_key_info(key_id)
    }

    fn destroy_key(&self, key_id: &KeyIdentifier) -> Result<(), KeyError<Self::Error>> {
        self.bind_ready_signers();
        self.get_signer_for_key(key_id)?.destroy_key(key_id)
    }

    fn sign<D: AsRef<[u8]> + ?Sized>(
        &self,
        key_id: &KeyIdentifier,
        algorithm: SignatureAlgorithm,
        data: &D,
    ) -> Result<Signature, SigningError<Self::Error>> {
        self.bind_ready_signers();
        self.get_signer_for_key(key_id)?.sign(key_id, algorithm, data)
    }

    fn sign_one_off<D: AsRef<[u8]> + ?Sized>(
        &self,
        algorithm: SignatureAlgorithm,
        data: &D,
    ) -> Result<(Signature, PublicKey), Self::Error> {
        self.bind_ready_signers();
        self.one_off_signer.sign_one_off(algorithm, data)
    }

    fn rand(&self, target: &mut [u8]) -> Result<(), Self::Error> {
        self.bind_ready_signers();
        if self.default_signer.supports_random() {
            self.default_signer.rand(target)
        } else {
            self.rand_fallback_signer.rand(target)
        }
    }
}

impl SignerRouter {
    pub async fn sign_with_key<What: SignWithKey>(
        &self, key_id: &KeyIdentifier, what: What
    ) -> Result<<What::Sign as Sign>::Final, SignerError> {
        self.bind_ready_signers();
        self.get_signer_for_key(key_id)?.sign_with_key(key_id, what).await
    }
}