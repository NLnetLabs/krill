use std::{path::PathBuf, sync::Arc};

use bytes::Bytes;
use kmip::{ConnectionDetails, KeyType};
use rpki::crypto::{
    signer::KeyError, KeyIdentifier, PublicKey, PublicKeyFormat, Signature, SignatureAlgorithm, Signer, SigningError,
};

use crate::daemon::config::Config;

use super::SignerError;

//------------ KmipSigner --------------------------------------------------

const TEMP_PUB_KEY_NAME: &'static str = "KrillKey-public";
const TEMP_PRIV_KEY_NAME: &'static str = "KrillKey-private";

fn default_kmip_port() -> u16 {
    // From: http://docs.oasis-open.org/kmip/profiles/v1.1/os/kmip-profiles-v1.1-os.html#_Toc332820682
    //   "KMIP servers using the Basic Authentication Suite SHOULD use TCP port number 5696, as assigned by IANA, to
    //    receive and send KMIP messages. KMIP clients using the Basic Authentication Suite MAY use the same 5696 TCP
    //    port number."
    5696
}

#[derive(Clone, Debug, Deserialize)]
pub struct ConfigSignerKmip {
    pub host: String,

    #[serde(default = "default_kmip_port")]
    pub port: u16,

    #[serde(default)]
    pub insecure: bool,

    #[serde(default)]
    pub server_ca_cert_path: Option<PathBuf>,

    #[serde(default)]
    pub client_cert_path: Option<PathBuf>,

    #[serde(default)]
    pub client_cert_private_key_path: Option<PathBuf>,

    #[serde(default)]
    pub username: Option<String>,

    #[serde(default)]
    pub password: Option<String>,
}

/// A KMIP based signer.
#[derive(Clone, Debug)]
pub struct KmipSigner {
    conn: Arc<ConnectionDetails>,
    supports_rng_retrieve: bool,
}

impl KmipSigner {
    pub fn build(config: Arc<Config>) -> Result<Self, SignerError> {
        let config = config.signer_kmip.as_ref().ok_or(
            SignerError::KmipError("Missing configuration file settings".into()))?;

        let mut conn = ConnectionDetails::new(config.host.clone(), config.port);

        if config.insecure {
            conn.set_insecure();
        } else if let Some(path) = &config.server_ca_cert_path {
            conn.set_server_ca_cert(path);
        }

        // TODO: Do we need to check that we have BOTH cert and key?
        if let Some(path) = &config.client_cert_path {
            conn.set_client_cert(path);
        }
        if let Some(path) = &config.client_cert_private_key_path {
            conn.set_client_cert_private_key(path);
        }

        match (&config.username, &config.password) {
            (None, None) => Ok(()),
            (None, Some(_)) => Err(SignerError::KmipError("Password specified but username missing".into())),
            (Some(_), None) => Err(SignerError::KmipError("Username specified but password missing".into())),
            (Some(u), Some(p)) => Ok(conn.set_credentials(u.clone(), p.clone())),
        }?;

        let conn = Arc::new(conn);

        // TODO: Is it okay to fail to start Krill if the KMIP server is unreachable?
        info!("KMIP: Discovering provider details using {}", &conn);
        let si = kmip::get_server_info(conn.clone())
            .map_err(|err| SignerError::KmipError(format!("Unable to query KMIP server info: {}", err)))?;

        // We don't check every possible operation that we might need, only the major ones
        for op in &[kmip::Operation::CreateKeyPair, kmip::Operation::Sign] {
            if !si.supported_ops.contains(&op) {
                return Err(SignerError::KmipError(
                    format!("KMIP server cannot be used as it lacks support for the {:?} operation", op)));
            }
        }

        let supports_rng_retrieve = si.supported_ops.contains(&kmip::Operation::RngRetrieve);

        if !supports_rng_retrieve {
            warn!("KMIP server does not support the Rng Retrieve operation. Random numbers will be generated by Krill.");
        }

        Ok(KmipSigner {
            conn,
            supports_rng_retrieve,
        })
    }

    fn get_public_key_from_id(&self, pub_id: &str) -> Result<PublicKey, SignerError> {
        let algorithm = PublicKeyFormat::Rsa;

        let rsa_public_key = kmip::get_rsa_key_material(self.conn.clone(), pub_id)
            .map_err(|err| SignerError::KmipError(format!("Failed to get key material: {}", err)))?;

        let rsa_public_key_bytes = match rsa_public_key {
            kmip::RsaPublicKey::DerEncoded(bytes) => {
                bytes
            }
            kmip::RsaPublicKey::Components { modulus, public_exponent } => {
                let modulus = bcder::Unsigned::from_be_bytes(modulus);
                let public_exp = bcder::Unsigned::from_be_bytes(public_exponent);
        
                let rsa_public_key = bcder::encode::sequence((modulus.encode(), public_exp.encode()));
        
                let mut bytes: Vec<u8> = Vec::new();
                rsa_public_key
                    .write_encoded(bcder::Mode::Der, &mut bytes)
                    .map_err(|err| {
                        SignerError::KmipError(format!(
                            "Failed to create DER encoded RSAPublicKey from constituent parts: {}",
                            err
                        ))
                    })?;
        
                bytes
            }
        };

        let subject_public_key = bcder::BitString::new(0, bytes::Bytes::from(rsa_public_key_bytes));

        use crate::bcder::encode::PrimitiveContent; // for .encode()
        let subject_public_key_info = bcder::encode::sequence((algorithm.encode(), subject_public_key.encode()));

        use crate::bcder::encode::Values; // for .write_encoded()
        let mut subject_public_key_info_source: Vec<u8> = Vec::new();
        subject_public_key_info
            .write_encoded(bcder::Mode::Der, &mut subject_public_key_info_source)
            .map_err(|err| {
                SignerError::KmipError(format!(
                    "Failed to create DER encoded SubjectPublicKeyInfo from constituent parts: {}",
                    err
                ))
            })?;

        // This public key format can be loaded with openssl dgst -keyform PEM if verifying manually that
        // signing is working. See below.
        // error!("XIMON: public key in PEM format:");
        // error!("-----BEGIN PUBLIC KEY-----");
        // error!(base64::encode(&subject_public_key_info_source)));
        // error!("-----END PUBLIC KEY-----");

        let public_key = PublicKey::decode(subject_public_key_info_source.as_slice()).map_err(|err| {
            SignerError::KmipError(format!(
                "Failed to create public key from the DER encoded SubjectPublicKeyInfo: {}",
                err
            ))
        })?;

        Ok(public_key)
    }

    fn find_key(
        &self,
        key_id: &KeyIdentifier,
        is_private: bool,
    ) -> Result<String, KeyError<SignerError>> {
        let key_name_prefix = hex::encode(key_id);

        let (key_type, key_name, human_key_class) = match is_private {
            false => (KeyType::PUBLIC, format!("{}-public", key_name_prefix), "public key"),
            true => (KeyType::PRIVATE, format!("{}-private", key_name_prefix), "private key"),
        };

        trace!(
            "KMIP: Finding key id for {} with ID {}",
            &human_key_class,
            &key_id
        );

        let results = kmip::locate(self.conn.clone(), Some(&key_name), Some(key_type))
            .map_err(|err| KeyError::Signer(SignerError::KmipError(format!(
                "Failed to perform find for {} with id {}: {}",
                &human_key_class, &key_id, err
            ))))?;

        match results.len() {
            0 => Err(KeyError::KeyNotFound),
            1 => Ok(results[0].clone()),
            _ => Err(KeyError::Signer(SignerError::Pkcs11Error(format!(
                    "More than one {} found with id {}", &human_key_class, &key_id)))),
        }
    }

    fn build_key(
        &self,
        algorithm: PublicKeyFormat,
    ) -> Result<(PublicKey, String, String), SignerError> {
        if !matches!(algorithm, PublicKeyFormat::Rsa) {
            return Err(SignerError::KmipError(format!(
                "Algorithm {:?} not supported while creating key",
                &algorithm
            )));
        }

        trace!("KMIP: Generating key pair");

        let (priv_id, pub_id) = kmip::create_rsa_key_pair(self.conn.clone(), TEMP_PUB_KEY_NAME, TEMP_PRIV_KEY_NAME, 2048)
            .map_err(|err| SignerError::KmipError(format!("Failed to create key: {}", err)))?;

        let public_key = self.get_public_key_from_id(&pub_id)?;
        let key_identifier = public_key.key_identifier();
        let key_name_prefix = hex::encode(key_identifier);
        let pub_key_name = format!("{}-public", &key_name_prefix);
        let priv_key_name = format!("{}-private", &key_name_prefix);

        kmip::set_key_name(self.conn.clone(), &pub_id, &pub_key_name)
            .map_err(|err| SignerError::KmipError(format!("Failed to set name on new public key: {}", err)))?;
        kmip::set_key_name(self.conn.clone(), &priv_id, &priv_key_name)
            .map_err(|err| SignerError::KmipError(format!("Failed to set name on new private key: {}", err)))?;

        debug!("KMIP: Generated pub/priv key pair with HSM IDs {} and {} and named {}-(public|private)", pub_id, priv_id, key_name_prefix);

        // It might be possible to combine this with the key creation step by setting an activation date attribute in
        // the past. At least one KMIP specification test case does this when registering (importing) a key, not sure if
        // it is possible when creating a key pair or if HSMs support it.
        kmip::activate_key(self.conn.clone(), &priv_id)
            .map_err(|err| SignerError::KmipError(format!("Failed to activate new private key: {}", err)))?;

        Ok((public_key, pub_id, priv_id))
    }

    fn sign_with_key<D: AsRef<[u8]> + ?Sized>(
        &self,
        priv_id: &str,
        algorithm: SignatureAlgorithm,
        data: &D,
    ) -> Result<Signature, SignerError> {
        debug!("KMIP: Signing");

        if algorithm.public_key_format() != PublicKeyFormat::Rsa {
            return Err(SignerError::KmipError(format!(
                "Algorithm public key format not supported for signing: {:?}",
                algorithm.public_key_format()
            )));
        }

        let signed = kmip::sign(self.conn.clone(), priv_id, data.as_ref())
            .map_err(|err| SignerError::KmipError(format!("Failed to sign: {}", err)))?;

        let sig = Signature::new(SignatureAlgorithm::default(), Bytes::from(signed.clone()));

        // temporarily for testing purposes log some data we can use to verify that signing is working correctly:
        //   (plus we also log the key identifier in the caller fn sign())
        // error!("XIMON: data to sign: {}", hex::encode(data));
        // error!("XIMON: signed data : {}", hex::encode(&signed));
        // error!("XIMON: signature   : {}", hex::encode(sig.value()));
        // with these values we can copy paste the hex data into files and use this command to convert it back to
        // binary:
        //   $ xxd -r -p <input hex file> <output binary file>
        // then we can export the public key from SoftHSMv2 with this command:
        //   $ pkcs11-tool --module /usr/local/lib/softhsm/libsofthsm2.so -p <USER_PIN> --read-object --type pubkey \
        //       --id <SIGNING KEY ID> -o /tmp/key.pub
        // then we can verify that the data was signed correctly with this command:
        //   $ openssl dgst -verify /tmp/key.pub -keyform DER -sha256 -signature /tmp/sig.bin -binary /tmp/in.bin
        //     Verified OK
        //
        // if you can't get the key out of the HSM using pkcs11-tool you can instead use the error! statements
        // above in get_public_key_from_id() which print out the public key in PEM format, and then use 
        // -keyform PEM with the openssl dgst command instead of -keyform DER.

        Ok(sig)
    }

    fn delete_key_pair(&self, key_id: &KeyIdentifier) -> Result<(), SignerError> {
        if let Ok(id) = self.find_key(key_id, false) {
            kmip::destroy_key(self.conn.clone(), &id)
                .map_err(|err| SignerError::KmipError(format!("Failed to destroy public key: {}", err)))?;
        }
        if let Ok(id) = self.find_key(key_id, true) {
            // We have to revoke (deactivate) the activated private key before we are allowed to destroy it.
            kmip::revoke_key(self.conn.clone(), &id)
                .map_err(|err| SignerError::KmipError(format!("Failed to revoke private key: {}", err)))?;

            kmip::destroy_key(self.conn.clone(), &id)
                .map_err(|err| SignerError::KmipError(format!("Failed to destroy private key: {}", err)))?;
        }
        Ok(())
    }
}

impl Signer for KmipSigner {
    type KeyId = KeyIdentifier;
    type Error = SignerError;

    // TODO: extend the fn signature to accept a context string, e.g. CA name, to label the key with?
    fn create_key(&mut self, algorithm: PublicKeyFormat) -> Result<Self::KeyId, Self::Error> {
        let (key, _, _) = self.build_key(algorithm)?;
        Ok(key.key_identifier())
    }

    fn get_key_info(&self, key_id: &Self::KeyId) -> Result<PublicKey, KeyError<Self::Error>> {
        let pub_id = self.find_key(key_id, false)?;
        self.get_public_key_from_id(&pub_id).map_err(|err| KeyError::Signer(err))
    }

    fn destroy_key(&mut self, key_id: &Self::KeyId) -> Result<(), KeyError<Self::Error>> {
        self.delete_key_pair(key_id).map_err(|err| KeyError::Signer(err))
    }

    fn sign<D: AsRef<[u8]> + ?Sized>(
        &self,
        key_id: &Self::KeyId,
        algorithm: SignatureAlgorithm,
        data: &D,
    ) -> Result<Signature, SigningError<Self::Error>> {
        let priv_id = self.find_key(key_id, true).map_err(|err| match err {
            KeyError::KeyNotFound => SigningError::KeyNotFound,
            KeyError::Signer(err) => SigningError::Signer(err),
        })?;

        // error!("XIMON: sign: key name prefix: {}", hex::encode(key_id));

        self.sign_with_key(&priv_id, algorithm, data)
            .map_err(|err| SigningError::Signer(err))
    }

    // TODO: As this requires creating a key, shouldn't this be &mut like create_key() ?
    fn sign_one_off<D: AsRef<[u8]> + ?Sized>(
        &self,
        algorithm: SignatureAlgorithm,
        data: &D,
    ) -> Result<(Signature, PublicKey), SignerError> {
        let (key, _, priv_id) = self.build_key(PublicKeyFormat::Rsa)?;

        let signature = self.sign_with_key(&priv_id, algorithm, data.as_ref())?;

        self.delete_key_pair(&key.key_identifier())?;

        Ok((signature, key))
    }

    fn rand(&self, target: &mut [u8]) -> Result<(), SignerError> {
        if self.supports_rng_retrieve {
            // Should we seed the random number generator?
            let random_value = kmip::generate_random(self.conn.clone(), target.len() as i32)
                .map_err(|err| SignerError::KmipError(format!("Failed to generate random value: {}", err)))?;
            target.copy_from_slice(random_value.as_slice());
            Ok(())
        } else {
            openssl::rand::rand_bytes(target)
                .map_err(|err| SignerError::KmipError(format!("Failed to generate ramdom value in s/w: {}", err)))
        }
    }
}
